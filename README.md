# Dota Origins Programming Guide

# Objects

Dota Origins contains several objects to make programming easier. These objects help us to reason about the game in terms humans can understand. For example, we could call every unit by a unique number, every square on the board by a unique number, and every ability a unit can cast by a unique number, but it would be very confusing and hard to understand, like phone numbers! Wouldn't it be better if we could call people by just saying their name into our phones? That is what objects do, they give our game's data nicknames and structure. The following are the objects used in our game and what they represent.

| Object | Description | Examples | Why
|--|--|--|--|
| Drafts | Unique unit type | Knight, Archer, Cleric | Easier to create units by copying unique drafts when building formations. Uses the DRY (Don't Repeat Yourself) principle.
| Units | Instances of drafts | Radiant Knight, Radiant Archer, Radiant Cleric, Dire Knight, Dire Archer, Dire Cleric | Every unit must have its own stats such as health which can change independently from all other units.
| Cells | 2D Location | A unit is standing on cell [x: 1, y: 1] | There is no height to our game board, so we don't really care about the Z dimension and only need to talk in terms of where units are in a 2D plane of X and Y.
| Pairs | Two cells | A unit standing on the first cell targets the second cell [ first: [x: 1, y: 1], second: [x: 5, y: 5] ] | When players move a unit, or use an ability, or orient to face a new direction with a unit, there are always two cells that are important: the source cell which the selected unit is on, and the target cell. Because this is so frequently used in diagrams, we make this handy pair object which is a combination of a first and second cell so we only have to pass one parameter, the Pair.
| Directions | Cardinal direction | A Knight attacks an Archer from the East while the Archer is facing West. | In our game, units can sometimes get lucky and block when attacked from the side or front. Therefore we need to know when a unit is being attacked from the side or the front as opposed to from the rear. We calculate this by getting the direction the victim unit is facing relative to the direction the attack is coming from. Directions are derived from the cells the units are on against the one they are facing toward or attacking.
| Paths | All of the cells that a unit will traverse when moving | [x: 1, y: 1], [x: 2, y: 1], [x: 3, y: 1], [x: 4, y: 1] | When a unit moves to a new cell, the starting cell, destination cell, and all cells in between are combined into a path. This path is then used to make the unit walk to each cell, in order, and also to check if there are any allies on the path that we need to move out of the way. 
| Headings | Tuple of cells | [ coming_from: [x: 1, y: 1], <br>heading_now: [x: 2, y: 1], <br>heading_next: [x: 3, y:1] ] | A heading is like a pair except it contains up to three cells and is used only when a unit is moving along a path and when an allied unit needs to move out of the way. Imagine the unit that's moving is walking to the West and is about to turn and move South. If there was an allied unit in the way we would need to know this was about to happen so that we move the allied unit West or North, since the walking unit is coming from the East and heading South, we don't want to move the unit out of the way in those directions as that would cause the units to collide! So, Headings contain the cell the walking unit is coming from, the cell it's heading to now, and the cell it's heading to next, in order to build the direction that it's coming from and the direction it's heading so that we move out of the way in the right direction. 
| Actions | Things that happen in a game that are recorded for making a replay later | Moving a unit, Casting an Ability, Orienting a Unit, Passing your turn, Surrendering, Sending a chat message, pausing the game, unpausing the game | In order to accurately recreate the game later in a replay, or store all of the relevant game information somewhere, we need to record everything that happens that materially changes the state of the game. This is like storing all of the moves and pauses in a game of Chess or Checkers.
| Maps | 2D Grid with 0's representing used locations and 1's representing unused locations | Phantom Assassin's Attack:<br>[1, 0, 1],<br>[0, 1, 0],<br>[1, 0, 1] | 2D Grids like this enable us to store complex AOE (Area of Effect) maps for abilities in a readable way. For example, Phantom Assassin attaks all neighboring cells by spinning with her blades. The example map to the left represents this - all the cells around the center of the grid are 0 which means those locations will be used for the attack. The center cell is 1, because Phantom Assassin doesn't damage herself. In order for there to be a center to a grid, there has to be an odd number of rows and columns, and the number of rows and columns has to be the same. The game board map itself is 13 rows by 13 columns for this reason.
| Offsets |  |
| Vectors | 3D Location | [x: x, y: y, z: z] | 
